# General python imports
import json
import logging
import pandas as pd
import numpy as np
from importlib import resources
from pathlib import Path

# Pyomo imports
from pyomo.environ import (ConcreteModel,
                           RangeSet,
                           Var,
                           NonNegativeReals,
                           Constraint,
                           Expression,
                           Objective,
                           value,
                           maximize,
                           units as pyunits)

# IDAES imports
from idaes.core.solvers import get_solver
from idaes.core.util.model_statistics import degrees_of_freedom
from idaes.apps.grid_integration import MultiPeriodModel

# Nuclear flowsheet function imports
from dispatches.case_studies.nuclear_case.nuclear_flowsheet import (
    build_ne_flowsheet,
    fix_dof_and_initialize,
)

from dispatches.case_studies.nuclear_case.representative_days_analysis.utils import \
    get_full_year_lmp

# Register currency as a unit
pyunits.load_definitions_from_strings(["USD = [currency]"])

CAPEX = {
    # "component": value * units
    "pem": 1630 * (pyunits.USD / pyunits.kW),
    "tank": 29 * (pyunits.USD / pyunits.kWh),
    "turbine": 947 * (pyunits.USD / pyunits.kW),
}

FOM = {
    # "component": value * units
    "pem": 47.9 * (pyunits.USD / pyunits.kW),
    "turbine": 7 * (pyunits.USD / pyunits.kW),
}

VOM = {
    # "component": value * units
    "pem": 1.3 * (pyunits.USD / pyunits.MWh),
    "turbine": 4.25 * (pyunits.USD / pyunits.MWh)
}
LHV_H2 = 33.3 * pyunits.kWh / pyunits.kg
MW_H2 = 2.016e-3 * pyunits.kg / pyunits.mol


def get_linking_variable_pairs(ct, ft):
    """Yield pairs of variables that need to be connected across time periods.

    The only variable that is connected across two time periods is the tank holdup.

    Args:
        ct: current time step
        ft: the next time step
    """
    return [(ct.fs.h2_tank.tank_holdup[0], ft.fs.h2_tank.tank_holdup_previous[0])]


def unfix_dof(m, air_h2_ratio=10.76):
    """
    This function unfixes a few degrees of freedom for optimization
    """
    # Unfix the electricity split in the electrical splitter
    m.fs.np_power_split.split_fraction["np_to_grid", 0].unfix()

    # Unfix the holdup_previous and outflow variables
    m.fs.h2_tank.tank_holdup_previous.unfix()
    m.fs.h2_tank.outlet_to_turbine.flow_mol.unfix()
    m.fs.h2_tank.outlet_to_pipeline.flow_mol.unfix()

    # Unfix the flowrate of air to the mixer
    m.fs.mixer.air_feed.flow_mol.unfix()

    # Add a constraint to maintain the air to hydrogen flow ratio
    m.fs.mixer.air_h2_ratio = Constraint(
        expr=m.fs.mixer.air_feed.flow_mol[0] ==
             air_h2_ratio * m.fs.mixer.hydrogen_feed.flow_mol[0])
    
    # Set bounds on variables. A small non-zero value is set as the lower 
    # bound on molar flowrates to avoid convergence issues
    m.fs.pem.outlet.flow_mol[0].setlb(0.001)

    m.fs.h2_tank.inlet.flow_mol[0].setlb(0.001)
    m.fs.h2_tank.outlet_to_turbine.flow_mol[0].setlb(0.001)
    m.fs.h2_tank.outlet_to_pipeline.flow_mol[0].setlb(0.001)

    m.fs.translator.inlet.flow_mol[0].setlb(0.001)
    m.fs.translator.outlet.flow_mol[0].setlb(0.001)

    m.fs.mixer.hydrogen_feed.flow_mol[0].setlb(0.001)


def add_capacity_variables(m):
    
    """
    This function declares the first-stage variables or design decisions, and
    adds constraints that ensure that the operational variables never exceed their
    design values.
    """
    if hasattr(m, "set_period"):
        set_period = m.set_period
    else:
        set_period = m.parent_block().set_period

    # Declare first-stage variables (Design decisions)
    m.pem_capacity = Var(
        within=NonNegativeReals,
        doc="Maximum capacity of the PEM electrolyzer (in kW)",
        units=pyunits.kW,
    )
    m.tank_capacity = Var(
        within=NonNegativeReals,
        doc="Maximum holdup of the tank (in mol)",
        units=pyunits.mol
    )
    m.h2_turbine_capacity = Var(
        within=NonNegativeReals,
        doc="Maximum power output from the turbine (in W)",
        units=pyunits.W
    )

    m.pem_capacity_constraint = Constraint(set_period)
    m.tank_capacity_constraint = Constraint(set_period)
    m.turbine_capacity_constraint = Constraint(set_period)

    for t in set_period:
        # Ensure that the electricity to the PEM elctrolyzer does not exceed the PEM capacity
        m.pem_capacity_constraint.add(
            t, m.period[t].fs.pem.electricity[0] <= m.pem_capacity
        )
        # Ensure that the final tank holdup does not exceed the tank capacity
        m.tank_capacity_constraint.add(
            t, m.period[t].fs.h2_tank.tank_holdup[0] <= m.tank_capacity
        )
        # Ensure that the power generated by the turbine does not exceed the turbine capacity
        m.turbine_capacity_constraint.add(
            t, - m.period[t].fs.h2_turbine.work_mechanical[0] <= m.h2_turbine_capacity
        )


def append_op_costs_and_revenue(m, lmp, h2_price):

    lmp = lmp * pyunits.USD / pyunits.MWh
    h2_price = h2_price * pyunits.USD / pyunits.kg

    m.fs.vom = Expression(
        expr=pyunits.convert(VOM["pem"] * m.fs.pem.electricity[0] * pyunits.h, to_units=pyunits.USD) -
        pyunits.convert(VOM["turbine"] * m.fs.h2_turbine.work_mechanical[0] * pyunits.h, to_units=pyunits.USD)
    )

    m.fs.electricity_revenue = Expression(
        expr= lmp * pyunits.convert(m.fs.np_power_split.np_to_grid_port.electricity[0] * pyunits.h, to_units=pyunits.MWh) -
        lmp * pyunits.convert(m.fs.h2_turbine.work_mechanical[0] * pyunits.h, to_units=pyunits.MWh)
    )

    m.fs.hydrogen_revenue = Expression(
        expr=pyunits.convert(h2_price * MW_H2 * m.fs.h2_tank.outlet_to_pipeline.flow_mol[0] * pyunits.h,
        to_units=pyunits.USD)
    )


def append_cashflows(m):

    if hasattr(m, "set_time"):
        ps = m                         # Object containing information on sets and parameters
    else:
        ps = m.parent_block()

    set_time = ps.set_time             # Set of hours
    set_years = ps.set_years           # Set of years
    plant_life = ps.plant_life         # Plant lifetime
    tax_rate = ps.tax_rate             # Corporate tax rate
    discount_rate = ps.discount_rate   # Discount rate

    representative_days = False
    if hasattr(ps, "set_days"):
        representative_days = True
        set_days = ps.set_days         # Set of days/clusters
        weights_days = ps.weights_days # Weights associated with each cluster

    years_vec = [y - set_years.at(1) + 1 for y in set_years]
    years_vec.append(plant_life + 1)
    weights_years = {y: sum(1 / (1 + discount_rate) ** i
                            for i in range(years_vec[j], years_vec[j + 1]))
                     for j, y in enumerate(set_years)}

    # PEM CAPEX: $1630/kWh and pem_capacity is in kW,
    # Tank CAPEX: $29/kWh, the LHV of hydrogen is 33.3 kWh/kg,
    # the molecular mass of hydrogen is 2.016e-3 kg/mol and
    # tank_capacity is in moles 
    # Turbine CAPEX: $947/kWh and turbine_capacity is in W
    m.capex = Expression(
        expr=(pyunits.convert(CAPEX["pem"] * m.pem_capacity, to_units=pyunits.USD) +
              pyunits.convert(CAPEX["tank"] * LHV_H2 * MW_H2 * m.tank_capacity, to_units=pyunits.USD) +
              pyunits.convert(CAPEX["turbine"] * m.h2_turbine_capacity, to_units=pyunits.USD)),
        doc="Total capital cost (in USD)"
    )

    # Fixed O&M of PEM: $47.9/kW
    # Fixed O&M of turbine: $7/kW
    @m.Expression(set_years,
                  doc="Fixed O&M cost per year (in USD)")
    def fixed_om_cost(blk, y):
        return (
            pyunits.convert(FOM["pem"] * m.pem_capacity, to_units=pyunits.USD) +
            pyunits.convert(FOM["turbine"] * m.h2_turbine_capacity, to_units=pyunits.USD)
        )

    # Variable O&M: PEM: $1.3/MWh and turbine: $4.25/MWh
    @m.Expression(set_years,
                  doc="Total variable O&M cost per year (in USD)")
    def variable_om_cost(blk, y):
        if representative_days:
            return (
                sum(weights_days[y][d] * blk.period[t, d, y].fs.vom 
                    for t in set_time for d in set_days) 
            )

        else:
            return sum(blk.period[t, y].fs.vom for t in set_time) 

    @m.Expression(set_years,
                  doc="Revenue generated by selling electricity per year (in USD)")
    def electricity_revenue(blk, y):
        if representative_days:
            return (
                sum(weights_days[y][d] * blk.period[t, d, y].fs.electricity_revenue
                    for t in set_time for d in set_days)
            )

        else:
            return sum(blk.period[t, y].fs.electricity_revenue for t in set_time)
        

    @m.Expression(set_years,
                  doc="Revenue generated by selling hydrogen per year (in USD)")
    def h2_revenue(blk, y):
        if representative_days:
            return (
                sum(weights_days[y][d] * blk.period[t, d, y].fs.hydrogen_revenue
                    for t in set_time for d in set_days)
            )

        else:
            return sum(blk.period[t, y].fs.hydrogen_revenue for t in set_time)

    @m.Expression(set_years,
                  doc="Depreciation value per year (in USD)")
    def depreciation(blk, y):
        return (
            blk.capex / plant_life
        )

    @m.Expression(set_years,
                  doc="Net profit per year (in USD)")
    def net_profit(blk, y):
        return (
            blk.depreciation[y] + (1 - tax_rate) * (+ blk.h2_revenue[y]
                                                    + blk.electricity_revenue[y]
                                                    - blk.fixed_om_cost[y]
                                                    - blk.variable_om_cost[y]
                                                    - blk.depreciation[y])
        )

    m.npv = Expression(
        expr=sum(weights_years[y] * m.net_profit[y] for y in set_years) - m.capex,
        doc="Net present value (in USD)"
    )


def build_multiperiod_representative_days(
    num_rep_days=20,
    set_years=[2022],
    h2_demand=1,
    filename="",
    dataset="INL",
    location=("CAISO", 100),
):
    m = MultiPeriodModel(
        n_time_points=24,
        set_days=[i for i in range(1, num_rep_days + 1)],
        set_years=set_years,
        process_model_func=build_ne_flowsheet,
        linking_variable_func=get_linking_variable_pairs,
        initialization_func=fix_dof_and_initialize,
        unfix_dof_func=unfix_dof,
        flowsheet_options={"np_capacity": 1000},
        initialization_options={
            "split_frac_grid": 0.8,
            "tank_holdup_previous": 0,
            "flow_mol_to_pipeline": 10,
            "flow_mol_to_turbine": 10,
        },
        use_stochastic_build=True,
        outlvl=logging.WARNING,
    )

    # Set initial holdup for each day
    for y in m.set_years:
        for d in m.set_days:
            m.period[1, d, y].fs.h2_tank.tank_holdup_previous.fix(0)

            for t in m.set_time:
                # m.period[t, d, y].fs.h2_tank.outlet_to_pipeline.flow_mol.setub(h2_demand / 2.016e-3)
                m.period[t, d, y].fs.h2_tank.outlet_to_pipeline.flow_mol.fix(h2_demand / 2.016e-3)

    add_capacity_variables(m)

    # Define parameters
    m.plant_life = 20                            # Plant lifetime: 20 years
    m.tax_rate = 0.2                             # Corporate tax rate: 20%
    m.discount_rate = 0.08                       # Discount rate: 8%
    m.h2_price = 3                               # Selling price of hydrogen: $3/kg
    m.h2_demand = 1                              # Maximum amount of hydrogen that can be sold: 1 kg/s

    if dataset == "INL":
        # Load the LMP dataset
        with resources.path("dispatches.case_studies.nuclear_case", "lmp_signal.json") as p:
            path_to_file = Path(p).resolve()

        with open(str(path_to_file)) as fp:
            lmp_dataset = json.load(fp)
            
        # Gather the LMP data needed for the deterministic case
        # Notation: lmp_dataset[scenario][year][cluster/day][time/hour]
        lmp_deterministic = {year: {cluster: {hour: lmp_dataset["0"][str(year)][str(cluster)][str(hour)]
                                            for hour in range(1, 25)} 
                                    for cluster in range(1, 21)}
                            for year in set_years}

        # Size of each cluster/number of days in a year represented by the cluster
        weights_days = {year: {cluster: lmp_dataset[str(0)][str(year)][str(cluster)]["num_days"]
                            for cluster in range(1, 21)}
                        for year in set_years}
        m.weights_days = weights_days

    elif dataset == "NREL":
        data_days = pd.read_excel(
            "nrel_12_rep_days.xlsx", 
            sheet_name='MiNg_$' + str(location[1]) + '_' + location[0],
        )
        data_weights = pd.read_excel(
            "nrel_12_rep_days_weights.xlsx", 
            sheet_name='MiNg_$' + str(location[1]) + '_' + location[0],
        )

        lmp_deterministic = {
            year: {
                day + 1: {
                    hour + 1: float(data_days[day][hour]) for hour in range(24)
                }
                for day in range(12)
            }
            for year in set_years
        }

        weights_days = {
            year: {
                day + 1: int(data_weights[0][day]) for day in range(12)
            }
            for year in set_years
        }
        m.weights_days = weights_days

    for (t, d, y) in m.set_period:
        append_op_costs_and_revenue(
            m.period[t, d, y], 
            lmp=lmp_deterministic[y][d][t],
            h2_price=m.h2_price,
        )

    append_cashflows(m)

    # Define the objective function
    m.obj = Objective(expr=m.npv, sense=maximize)

    # Define the solver object. Using IPOPT
    solver = get_solver()

    # Solver the optimization problem
    result = solver.solve(m, tee=True)

    # Print Results
    print("Optimal PEM capacity    : ", m.pem_capacity.value * 1e-3, "MW")
    print("Optimal tank capacity   : ", m.tank_capacity.value * 2.016e-3, "kg")
    print("OPtimal turbine capacity: ", m.h2_turbine_capacity.value * 1e-6, "MW")

    schedule = {
        y: {
            d: {
                t: {
                    "power_to_pem": m.period[t, d, y].fs.pem.electricity[0].value,
                    "h2_to_turbine": m.period[t, d, y].fs.h2_tank.outlet_to_turbine.flow_mol[0].value,
                    "h2_to_market": m.period[t, d, y].fs.h2_tank.outlet_to_pipeline.flow_mol[0].value,
                    "tank_holdup": m.period[t, d, y].fs.h2_tank.tank_holdup[0].value,
                }
                for t in m.set_time
            }
            for d in m.set_days
        }
        for y in m.set_years
    }

    results = {
        "solver_status": str(result["Solver"][0]["Termination condition"]),
        "Optimal PEM capacity": m.pem_capacity.value,
        "Optimal tank capacity": m.tank_capacity.value,
        "Optimal turbine capacity": m.h2_turbine_capacity.value,
        "OPtimal NPV": value(m.npv),
        "Optimal schedule": schedule,
    }

    with open(filename + "_rep_days.json", "w") as fp:
        json.dump(results, fp, indent=4)

    return m


def build_multiperiod_full_year(
    set_years=[2022],
    h2_demand=1,
    filename="",
    dataset="INL",
    location=("CAISO", 100),
):
    m = MultiPeriodModel(
        n_time_points=364 * 24,
        set_years=set_years,
        process_model_func=build_ne_flowsheet,
        linking_variable_func=get_linking_variable_pairs,
        initialization_func=fix_dof_and_initialize,
        unfix_dof_func=unfix_dof,
        flowsheet_options={"np_capacity": 1000},
        initialization_options={
            "split_frac_grid": 0.8,
            "tank_holdup_previous": 0,
            "flow_mol_to_pipeline": 10,
            "flow_mol_to_turbine": 10,
        },
        use_stochastic_build=True,
        outlvl=logging.WARNING,
    )

    h2_demand = np.random.uniform(low=0.2, high=2, size=364*24)

    # Set initial holdup of the tank
    for y in m.set_years:
        m.period[1, y].fs.h2_tank.tank_holdup_previous.fix(0)

        for t in m.set_time:
            # m.period[t, y].fs.h2_tank.outlet_to_pipeline.flow_mol.setub(h2_demand / 2.016e-3)
            m.period[t, y].fs.h2_tank.outlet_to_pipeline.flow_mol.fix(h2_demand[t - 1] / 2.016e-3)

    add_capacity_variables(m)

    # Define parameters
    m.plant_life = 20                            # Plant lifetime: 20 years
    m.tax_rate = 0.2                             # Corporate tax rate: 20%
    m.discount_rate = 0.08                       # Discount rate: 8%
    m.h2_price = 3                               # Selling price of hydrogen: $3/kg
    m.h2_demand = 1                              # Maximum amount of hydrogen that can be sold: 1 kg/s

    if dataset == "INL":
        # Load the LMP dataset
        with resources.path("dispatches.case_studies.nuclear_case", "lmp_signal.json") as p:
            path_to_file = Path(p).resolve()

        with open(str(path_to_file)) as fp:
            lmp_dataset = json.load(fp)
            
        # Gather the LMP data needed for the deterministic case
        # Notation: lmp_dataset[scenario][year][cluster/day][time/hour]
        lmp_deterministic = {year: {cluster: {hour: lmp_dataset["0"][str(year)][str(cluster)][str(hour)]
                                            for hour in range(1, 25)} 
                                    for cluster in range(1, 21)}
                            for year in set_years}

        lmp_deterministic = get_full_year_lmp(lmp_deterministic)

    elif dataset == "NREL":
        raw_data = pd.read_excel(
            "FLECCS_Price_Series_Data_01_20_2021.xlsx",
            sheet_name="2035 - NREL",
        )
        sheet_name = 'MiNg_$' + str(location[1]) + '_' + location[0]
        price_all = raw_data[sheet_name].tolist()

        lmp_deterministic = {
            year: {
                hour + 1: lmp for hour, lmp in enumerate(price_all)
            }
            for year in set_years
        }

    for (t, y) in m.set_period:
        append_op_costs_and_revenue(
            m.period[t, y], 
            lmp=lmp_deterministic[y][t],
            h2_price=m.h2_price,
        )

    append_cashflows(m)

    # Define the objective function
    m.obj = Objective(expr=m.npv, sense=maximize)

    # Define the solver object. Using IPOPT
    solver = get_solver()

    # Solver the optimization problem
    result = solver.solve(m, tee=True)

    # Print Results
    print("Optimal PEM capacity    : ", m.pem_capacity.value * 1e-3, "MW")
    print("Optimal tank capacity   : ", m.tank_capacity.value * 2.016e-3, "kg")
    print("OPtimal turbine capacity: ", m.h2_turbine_capacity.value * 1e-6, "MW")

    schedule = {
        y: {
            t: {
                "power_to_pem": m.period[t, y].fs.pem.electricity[0].value,
                "h2_to_turbine": m.period[t, y].fs.h2_tank.outlet_to_turbine.flow_mol[0].value,
                "h2_to_market": m.period[t, y].fs.h2_tank.outlet_to_pipeline.flow_mol[0].value,
                "tank_holdup": m.period[t, y].fs.h2_tank.tank_holdup[0].value,
            }
            for t in m.set_time
        }
        for y in m.set_years
    }

    results = {
        "solver_status": str(result["Solver"][0]["Termination condition"]),
        "Optimal PEM capacity": m.pem_capacity.value,
        "Optimal tank capacity": m.tank_capacity.value,
        "Optimal turbine capacity": m.h2_turbine_capacity.value,
        "OPtimal NPV": value(m.npv),
        "Optimal schedule": schedule,
    }

    with open(filename + "_full_year.json", "w") as fp:
        json.dump(results, fp, indent=4)

    return m



# TODO:
# Reduce the capex of pem and see if the solution changes.
# Variable demand 
# Variable hydrogen pricing